# errisy-tsc
a customized typescript compiler transpiler

## why transpile?
In web devleopment, the communication between front end and back end have been an issue. Back end developers are normally required to write documentations for font end usage.

TypeScript has the advantage of applying dev-time type constrains in the codes to avoid tons of errors. TypeScript IDE in Visual Studio can also show the comments/descriptions for each class and function.

** Would it be fantastic if you back end classes can be transpiled into client classes? So you can CALL back end functions directly in your font end code **

## So we got an solution here:

Simple write your service as classes in *.rpc.ts files and extends from rpc.RPCService.

use **@rpc.service** to decorate the service class that you want to expose to the client.
use **@rpc.member** to decorate the member that you want to expose to the client.

**app.rpc.ts:**
```
/// <transpile path="C:\HTTP\npm\errisy-tsc\csclient.cs"/>
import * as rpc from 'errisy-rpc';
import { ImageItem } from './imageitem';
/**
 * the RPC service example.
 */
@rpc.service
export class AppService extends rpc.RPCService {
    /**
     * this is genarate a list of image slides for the front end to display
     */
    @rpc.member
    public async ImageList(): Promise<ImageItem[]> {
        return [
            new ImageItem('img/1.jpg', 300, 1000),
            new ImageItem('img/2.jpg', 500, 2000),
            new ImageItem('img/3.jpg', 200, 400),
            new ImageItem('img/4.jpg', 100, 800),
            new ImageItem('img/5.jpg', 300, 1400),
        ]
    }
}
```
So here is the transpiled client for Angular 2.
You can simply inject it into any Angular 2 component and use it to call it by await (because all rpc calls are wrapped in the async functions)
You can also invoke it by calling the [ImageList url] field, which is the link for it: "/app/app.rpc.js?AppService-ImageList&"

**Check out the magic of comments** The comments are also copied from the service to the client. That means the front end developers will see the output.

**app.rpc.ts:**
```
//Client file generated by RPC Compiler.
import { Injectable } from '@angular/core';
import { Http, Response } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import { Observer } from 'rxjs/Observer';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';
import * as rpc from 'errisy-rpc';

import { ImageItem } from './imageitem';
/**
 * the RPC service example.
 */
@Injectable()
export class AppService {
	constructor(private $_Angular2HttpClient: Http){
	}
	/**Please set Base URL if this Remote Procedure Call is not sent to the default domain address.*/
	public $baseURL: string = "";
		/**
		 * this is genarate a list of image slides for the front end to display
		 */
		public ImageList(): Promise<ImageItem[]>{
			return this.$_Angular2HttpClient.post(this.$baseURL + '/app/app.rpc.js?AppService-ImageList', rpc.buildClientData()).map(rpc.Converter.convertJsonResponse).toPromise();
		}
		public get "ImageList url"():string{
			return this.$baseURL + "/app/app.rpc.js?AppService-ImageList&";
		}
}

```

## Transpiled C#:

C# can call the service as well with automatically generated front end client file! (For example, Xamarin project, Windows Desktop/WPF/Winform projects).
You must include the C# PolyFill for your C# front end.
Make sure you set the transpile path properly: 
**/// <transpile path="path in your computer"/>**
```CSharp
//Data Type Definition Generated by RPC compiler. Please do not modify this file.
namespace app
{
	/// <summary>
	/// the RPC service example.
	/// </summary>
	public class AppService
	{
		public AppService(string baseUrl){
			BaseUrl = baseUrl;
		}
		public string BaseUrl { get; set; }
		/// <summary>
		/// this is genarate a list of image slides for the front end to display
		/// </summary>
		public async System.Threading.Tasks.Task<ImageItem[]> ImageList()
		{
			return NodeJSRPC.Converter.convertJsonResponse<ImageItem[]>(await NodeJSRPC.HttpClient.Post(this.BaseUrl + "/app/app.rpc.js?AppService-ImageList", ));
		}
	}
}
```

#Can this handle file upload?
Yes! 
Use rpc.Polyfill.File to handle client side JavaScript File objects and rpc.Polyfill.Blob to handle client side JavaScript Blob objects.
This works for C# as well. Check it out yourself in the client files.

```
/// <transpile path="C:\HTTP\npm\errisy-tsc\csclient.cs"/>

import * as rpc from 'errisy-rpc';
import { ImageItem } from './imageitem';

/**
 * the RPC service example.
 */
@rpc.service
export class AppService extends rpc.RPCService {

    /**
     * this is genarate a list of image slides for the front end to display
     */
    @rpc.member
    public async ImageList(): Promise<ImageItem[]> {
        return [
            new ImageItem('img/1.jpg', 300, 1000),
            new ImageItem('img/2.jpg', 500, 2000),
            new ImageItem('img/3.jpg', 200, 400),
            new ImageItem('img/4.jpg', 100, 800),
            new ImageItem('img/5.jpg', 300, 1400),
        ]
    }
    /**
     * File upload
     * @param file
     */
    @rpc.member
    public async upload(file: rpc.Polyfill.File): Promise<string> {

    }
    /**
     * transfer of bytes
     * @param file
     */
    @rpc.member
    public async transfer(file: rpc.Polyfill.Blob): Promise<boolean> {

    }
}
```


##Work with errisy-server

errisy-server is an out-of-box http server written fully in the async/await middlewares.

##Warning of More Features:
I also made the TypeScript compiler to generate async methods that support cancel!
[TypeScript __awaiter support cancel!](https://github.com/Microsoft/TypeScript/issues/13854)

** In both front end and back end, you may have cases where you want to stop a Promise gracefully, but you can't do it with stardard Promise **

So here, without using RxJS, a few lines of codes in the __awaiter solved the cancel problem! In the errisy-tsc compiler, the __awaiter function returns a Task object instead of Promise (when you have npm module errisy-task available).

** Task object is cancellable and will append all internal Promises or Tasks in your async functions as its children and remove them when they are completed (remove to avoid error when you run animation script for ever) ** So when you cancel the task, it cancels all child tasks in the async function. That turns your async function very managable!
